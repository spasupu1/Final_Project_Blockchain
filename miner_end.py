

'''
This program is used by the Miner for transaction verification and
also Mining a new block.
After a new transaction is generated by the user,
A miner need to verify it using this program.
'''


import hashlib
import json
import yaml
from time import time
from tkinter import *
import tkinter as tk
import binascii
import os
from Crypto.Hash import SHA
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5

'''
Mining difficulty is the number of '0's should be present
at the starting of the hash,
The hiher the length, more difficult to mine.
'''

Mining_difficulty = 4
current_transactions = []
f = open("blockchain.txt", "r")
chain = yaml.load(f.read())
current_transactions = (chain[-1]["transactions"])
previous_block_hash = chain[-1]["previous_block_hash"]
last_block = chain[-1]
dir_path = os.path.dirname(os.path.realpath(__file__))


def login():
    '''
    THis function is called when a miner clicks on login.
    It verifies your credentials and logs you in.

    '''
    global screen1
    screen1 = Toplevel(screen)
    screen1.title("Login")
    screen1.geometry("500x550")
    Label(screen1, text="Research Flow", bg="#787878",
          width="300", height="2", font=("Luminari", 17),
          fg="white").pack()

    global login_user
    global login_password
    global login_user_entry
    global login_password_entry
    login_user = StringVar()
    login_password = StringVar()

    Label(screen1, text="Please enter your details below").pack()
    Label(screen1, text="").pack()
    Label(screen1, text="Username * ").pack()
    login_user_entry = Entry(screen1, textvariable=login_user)
    login_user_entry.pack()
    Label(screen1, text="Password * ").pack()
    login_password_entry = Entry(screen1, textvariable=login_password)
    login_password_entry.pack()
    Label(screen1, text="").pack()
    Button(screen1, text="Login", width=10,
           height=1, command=login_check).pack()


def login_check():
    '''
    Verify login credentials.
    yaml converts the string into its respective datatype.
    uses isfile function of os to check whether the file is present or not.
    '''
    login_user_entry = login_user.get()
    login_password_entry = login_password.get()
    if os.path.isfile(dir_path + "/user_database/" +
                      login_user_entry + "_Wallet.txt"):
        f = open(dir_path + "/user_database/" +
                 login_user_entry + "_Wallet.txt", "r")
        data = yaml.load(f.read())
        f.close()
        if data['password'] == login_password_entry:
            main_screen()
        else:
            Label(screen1, text="Username or password incorrect",
                  fg="red").pack()
    else:
        Label(screen1, text="You are not registered, please register",
              fg="green", font=("calibri", 11)).pack()


def transaction():
    '''
    This function is called when the miner choose to verify a transaction.
    He get the lsit of open transaction and thus
    can verify them by clicking verify.
    Uses yaml module
    '''
    global screen3
    screen3 = Toplevel(screen)
    screen3.title("New transaction")
    screen3.geometry("500x610")

    global sender_public_address
    global message
    global signature
    global reciever_public_address

    global sender_public_address_entry
    global message_entry
    global reciever_public_address_entry
    global signature_entry

    sender_public_address = StringVar()
    message = StringVar()
    signature = StringVar()
    reciever_public_address = StringVar()
    f = open('open_transactions.txt', "r")
    data = yaml.load(f.read())
    if data == []:
        Label(screen3, text="**No open transactions**",
              fg="green", font=("Times", 17)).pack()
    else:
        Label(screen3, text="Please Verify these open transactions").pack()
        Label(text="").pack()
        Label(text="").pack()
        T = tk.Text(screen3, height=7, width=63)
        T.pack()
        T.insert(tk.END, data)
        Button(screen3, text='Submit', height="4",
               width="20", command=verify_transaction_signature).pack()


def verify_transaction_signature():
    '''
    This function verifies the transaction signed by
    the user using RSA encryption modules.
    Its pops out the verified transactions from the file.
    Calls send_message and add_transaction function
    Uses Crypto PKCS1_v1_5, RSA modules
    '''
    f = open('open_transactions.txt', "r")
    data = yaml.load(f.read())
    sender_public_address = data[-1]['sender_public_address']
    reciever_public_address = data[-1]['reciever_public_address']
    signature = data[-1]['transaction_signature']
    message = data[-1]['message']
    sender_name = data[-1]['sender_name']

    public_key = RSA.importKey(binascii.unhexlify(sender_public_address))
    verifier = PKCS1_v1_5.new(public_key)
    h = SHA.new(str(message).encode('utf8'))
    if verifier.verify(h, binascii.unhexlify(signature)):
        Label(screen3, text="Verification Succesful \n"
                            "Your message successfully sent"
                            "and transaction added").pack()
        data.pop(-1)
        f = open('open_transactions.txt', "w")
        f.write(str(data))
        f.close()
        send_message(message, reciever_public_address, sender_name)
        add_transaction(sender_public_address,
                        reciever_public_address, message)
    else:
        Label(screen3, text="Verification failed").pack()



def send_message(message, reciever_public_address, sender_name):
    '''
    This function saves the message sent by the sender  
    into reciever's Wallet file.
    **Parameters**
    message: The message sent by the sender
    reciever_public_address: address input by the sender to send the file to.
    sender_name: name of the sender retrieved from the open transactions file.
    Uses os, yaml modules
    '''

    f1 = open(dir_path + "/user_database/userkeys.txt", "r")
    file = yaml.load(f1.read())
    print (file)
    # checks if the user address is out database or not.
    try:
        reciever_name = file[reciever_public_address]

        f = open(dir_path + "/user_database/" +
                 reciever_name + "_Wallet.txt", "r")
        user = yaml.load(f.read())
        f.close()
        user['recieved_messages'].append(["recieved from: " +
                                          sender_name, "message: " + message])

        f = open(dir_path + "/user_database/" +
                 reciever_name + "_Wallet.txt", "w")
        f.write(str(user))
        f.close()
    except KeyError:
        Label(screen3, text="No such reciever's address"
                            "in our database").pack()


def add_transaction(sender_public_address, reciever_public_address, message):
    '''
    Once the transaction is verifed it is added to the
    last block of the blockchain.
    ***Parameters***
    message: The message sent by the sender
    reciever_public_address: address input by the sender to send the file to.
    sender_public_address: address of the sender retrieved
    from the open transactions file.
    Calls update_last_block to update the last block
    '''
    current_transactions = ({
                            'timestamp': time(),
                            'sender_public_address': sender_public_address,
                            'reciever_public_address': reciever_public_address,
                            'message': message})

    update_last_block(current_transactions)


def update_last_block (current_transactions):
    '''
    This function appends the transaction to the
    last block ['transactions'] key.

    '''

    chain[-1]['transactions'].append(current_transactions)
    k = "transaction successfully added to block: ", chain.index(chain[-1]) + 1
    Label(screen3, text=k).pack()

    f = open("blockchain.txt", "w")
    f.write(str(chain))
    f.close()


def hash(block):
    '''
    This function hashes the block which is given to it.
    It returns the hash value usually in the name of previous block hash
    Uses Crypto hash module.
    '''
    block_string = json.dumps(block, sort_keys=True).encode()
    previous_block_hash = hashlib.sha256(block_string).hexdigest()
    return previous_block_hash


def new_block(previous_block_hash, nonce, miner_public_address):
    '''
    This function creates a new block which has the details of miner, nonce,
    index and previous block hash
    Check whether any block is modified or not, if found good,
    only then it allows you to mine and add a block.
    ***Parameters***
    previous_block_hash: hash of the previous block
    nonce: a number for which the mathematical hashing puzzle worked
    miner_public_address: address of the miner who mined it.
    '''
    if len(chain) == 1:
        current_transactions = []
        current_transactions.append({
                                    'timestamp': time(),
                                    'sender_public_address': 'Blockchain',
                                    'reciever_public_'
                                    'address': miner_public_address,
                                    'message': 'congratualtions '
                                    'you won 10 BTC as a reward'})

        block = {'index': len(chain), 'timestamp': time(),
                 'transactions': current_transactions, 'nonce': nonce,
                 'previous_block_hash': previous_block_hash}

        chain.append(block)
        return chain

    elif len(chain) > 1 and hash(chain[-2]
                                 ) == chain[-1]['previous_block_hash']:
        current_transactions = []
        current_transactions.append({
                                    'timestamp': time(),
                                    'sender_public_address': 'Blockchain',
                                    'reciever_public_'
                                    'address': miner_public_address,
                                    'message': 'congratualtions '
                                    'you won 10 BTC as a reward'})

        block = {'index': len(chain), 'timestamp': time(),
                 'transactions': current_transactions, 'nonce': nonce,
                 'previous_block_hash': previous_block_hash}

        chain.append(block)
        return chain
    else:
        return False


def proof_of_work():
    '''
    This function is the proof of your mining work.
    It give the nonce value at which the problem got solved.
    '''

    last_hash = last_block["previous_block_hash"]
    transactions = chain[-1]['transactions']

    nonce = 0
    while valid_proof(transactions, last_hash, nonce) is False:
        nonce += 1
    return nonce


def valid_proof(transactions, last_hash, nonce, difficulty=Mining_difficulty):
    '''
    This function attaches transactions, last hash and a
    nonce value and hashes it.
    The nonce value at which the hash starting letters are '0000',
    is the one we want to mine a new block.
    ***Parameters***
    transactions : list of last block transactions
    last_hash: hash of the last block
    nonce: starts from 0 to till we got the problem solved
    difficulty: a number which says how many 0's at the starting.
    Uses Crypto hash module.
    '''
    guess = (str(transactions) + str(last_hash) + str(nonce)).encode()
    guess_hash = hashlib.sha256(guess).hexdigest()
    return guess_hash[:difficulty] == '0' * difficulty


def mine():
    '''
    This function is called after submitting your public address.
    It takes the miner address, nonce, last block hash and the new chain from
    different functions and modifies the blockchain text file for further use.
    '''
    miner_public_address = miner_public_address_entry.get()
    nonce = proof_of_work()
    previous_block_hash = hash(last_block)
    chain = new_block(previous_block_hash, nonce, miner_public_address)
    if chain is False:
        Label(screen2, text='Sorry a block cannot be mined,'
                            'the blockchain seems to be modified').pack()
    else:
        f = open("blockchain.txt", "w")
        f.write(str(chain))
        f.close()
        Label(screen2, text='Congratulations your new block is successfully'
                            'forged \n you have been rewarded 10 BTC').pack()


def ready_to_mine():
    '''
    This functions is called when you prefer to mine a
    new block on the main screen.
    It takes address to whom miner want to send the reward.
    '''
    global screen2
    screen2 = Toplevel(screen)
    screen2.title("Mine a block")
    screen2.geometry("500x610")

    global miner_public_address
    global miner_public_address_entry
    miner_public_address = StringVar()
    Label(screen2, text="Please enter your public address:",
          font=("Times New Roman", 15)).pack()
    miner_public_address_entry = Entry(screen2,
                                       textvariable=miner_public_address)
    miner_public_address_entry.pack()
    Button(screen2, text='Submit', height="4", width="20", command=mine).pack()


def main_screen():
    '''
    This the screen displayed when the used logged in to his account.
    It askes the miner to choose his preference to mine a
    block or verify a transaction.
    '''

    global screen2
    screen2 = Toplevel(screen)
    screen2.geometry("400x550")
    screen2.title("Blockchain Backend")
    Label(screen2, text="Blockchain_Implementation",
          bg="grey", width="300", height="2", font=("Arial", 13)).pack()

    Label(screen2, text="Welcome miners").pack()
    Label(screen2, text="Please choose a selection").pack()
    Label(screen2, text="").pack()

    Button(screen2, text="Verify a new open transaction",
           height="6", width="30", command=transaction).pack()

    Label(screen2, text="").pack()
    Button(screen2, text='Mine a block',
           height="6", width="30", command=ready_to_mine).pack()
    Label(screen2, text="").pack()


def first_screen():
    '''
    This is the main screen which opens when the program runs.
    it is called in the main function of the program.
    Its shows hte logo and ask the miner to login.
    It calls the tkinter module and mainloop() executes the GUI.
    '''
    global screen
    screen = tk.Tk()
    screen.geometry("400x550")
    screen.title("Research Flow")
    Label(text="Research Flow", bg="#787878",
          width="300", height="2", font=("Luminari", 17),
          fg="white").pack()
    Label(text="Good Morning, Welcome to Research Flow",
          bg="#787878", fg="white", font=("Arial", 14)).pack()
    Label(text="Our service is transparent, open, secure and hack proof.",
          bg="#787878", fg="white", font=("Arial", 14)).pack()
    Label(text="Please login or register.",
          bg="#787878", fg="white", font=("Arial", 14)).pack()
    Label(text="").pack()
    Button(text='Login', height="4", width="30",
           font=("Times New Roman", 14), command=login).pack()
    Label(text="").pack()

    tk.mainloop()


if __name__ == '__main__':
    '''
    Tis i the main function which only calls first screen function
    '''
    first_screen()
